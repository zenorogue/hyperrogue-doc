<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HyperRogue: Welcome to the HyperRogue documentation!</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="hr-icon-png96.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HyperRogue
   &#160;<span id="projectnumber">11.2c</span>
   </div>
   <div id="projectbrief">game/visualization engine based on non-Euclidean geometry</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Welcome to the HyperRogue documentation! </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Documentation is in progress. Most functions are not explained yet.</p>
<h1>Guided Tour </h1>
<p>HyperRogue started as a very simple project: one geometry, one map structure, one projection, one mechanics, one way to play the game (OK, there were two monster types). Today, HyperRogue has over 60 lands with unique mechanics, about 40 geometries (including 2D, 3D, and non-isotropic ones) displayed in over 20 projections, many modes which completely change the gameplay, and even non-game modes for mathematical or data visualization. As a result, it is quite easy to get lost &ndash; not only because it is a very big project, but also because some of the early design decisions which were more appropriate for small projects, or may make some things somewhat illogical now.</p>
<p>Where should one start when reading the source code, then?</p>
<p>The main files which hold everything together are:</p>
<ul>
<li><a class="el" href="sysconfig_8h.html" title="set compiler flags, and include all the required system headers">sysconfig.h</a> &ndash; loads libraries, sets various <code>CAP_*</code> (capability) compiler flags. These can be used to enable or disable parts of HyperRogue, due to missing libraries/hardware capabilities, or to save on compilation time / executable size. (Not all combinations work.)</li>
<li>classes.h &ndash; defines enums related to content (lands, walls, monsters, items, geometries, projections).</li>
<li><a class="el" href="hyper_8h.html" title="The main header file of HyperRogue.">hyper.h</a> &ndash; this defines the basic general templates used everywhere in the game, as well as macro definitions which change depending on game mode or geometry (such as <code>S7</code> which is the number of edges in the pure geometry, <code>R10</code> which is the number of treasure to collect to advance, or <code>sphere</code> which tells us whether we are playing in spherical geometry), and some chaotic stuff which has not been moved elsewhere.</li>
<li>autohdr.h &ndash; this file is generated automatically by <code>makeh</code>. It contains the headers for all the functions and structs defined anywhere in the game (EX and <code>#if HDR</code> tell makeh to put a header for the given entity in autohdr.h), so usually it is better to read those other files directly.</li>
</ul>
<p>Interesting CPP files, arranged from the most basic ones:</p>
<ul>
<li><a class="el" href="hyperpoint_8cpp.html" title="basic computations in non-Euclidean geometry">hyperpoint.cpp</a> &ndash; computations which make non-Euclidean geometry work. An uniform system is used for continuous hyperbolic, Euclidean, and spherical geometries, in 2D and 3D (for nonisotropic geometries see <a class="el" href="nonisotropic_8cpp.html" title="nonisotropic spaces (Solv and Nil)">nonisotropic.cpp</a>). The most important types are <a class="el" href="structhr_1_1hyperpoint.html" title="A point in our continuous space Originally used for representing points in the hyperbolic plane....">hr::hyperpoint</a> (a vector in homogeneous coordinates) and <a class="el" href="structhr_1_1transmatrix.html" title="A matrix acting on hr::hyperpoint Since we are using homogeneous coordinates for hr::hyperpoint,...">hr::transmatrix</a> (a matrix).</li>
<li><a class="el" href="locations_8cpp.html" title="definition of connection tables, walkers, cell and heptagon structures">locations.cpp</a> &ndash; this defines the abstract classes used for representing maps. Important types are <a class="el" href="structhr_1_1cell.html">hr::cell</a> (actual cells used by the game), <a class="el" href="structhr_1_1heptagon.html">hr::heptagon</a> (coarser structure used in the default and some other geometries, this corresponds to heptagons in the standard geometry, but may have nothing to do with heptagons in general), and <a class="el" href="structhr_1_1walker.html">hr::walker</a> (which handle navigation on the map).</li>
<li><a class="el" href="heptagon_8cpp.html" title="implementation of Heptagons">heptagon.cpp</a> &ndash; this builds the structure of heptagons (see <a href="http://roguetemple.com/z/hyper/dev.php">this guide</a>) in the standard geometries on the hyperbolic planes. Other geometries are built in different ways, so they do not use this much. This graph is built in an abstract way, i.e., not using the computations from <a class="el" href="hyperpoint_8cpp.html" title="basic computations in non-Euclidean geometry">hyperpoint.cpp</a>.</li>
<li><a class="el" href="cell_8cpp.html" title="General cells and maps.">cell.cpp</a> &ndash; in the standard map, this builds the actual game graph, by bitruncating the graph of heptagons (pure geometries are also handled here, but Goldberg and irregular variations are defined in <a class="el" href="goldberg_8cpp.html" title="Goldberg-Coxeter construction.">goldberg.cpp</a> and <a class="el" href="irregular_8cpp.html" title="Irregular (Voronoi) tilings.">irregular.cpp</a>). It also defines the basic class <a class="el" href="structhr_1_1hrmap.html">hr::hrmap</a> (used in all kinds of geometries), <a class="el" href="structhr_1_1hrmap__hyperbolic.html">hr::hrmap_hyperbolic</a> (used in 2D hyperbolic geometries), and many functions dealing with the game graph, such as computing the distances.</li>
<li><a class="el" href="classes_8cpp.html" title="items, monsters, walls, lands, descriptions, etc.">classes.cpp</a> &ndash; <a class="el" href="classes_8cpp.html" title="items, monsters, walls, lands, descriptions, etc.">classes.cpp</a> defines the available geometries and projections, and some extra definitions for game content.</li>
<li><a class="el" href="geometry_8cpp.html" title="Calculation of basic, and less basic, constants in each geometry.">geometry.cpp</a> &ndash; this specifies how the discrete tessellation from <a class="el" href="heptagon_8cpp.html" title="implementation of Heptagons">heptagon.cpp</a> and <a class="el" href="cell_8cpp.html" title="General cells and maps.">cell.cpp</a> connects to the underlying continuous geometry (<a class="el" href="hyperpoint_8cpp.html" title="basic computations in non-Euclidean geometry">hyperpoint.cpp</a>). More advanced routines are in <a class="el" href="geometry2_8cpp.html" title="Matrices to transform between coordinates of various cells, coordinates of cell corners,...">geometry2.cpp</a>.</li>
<li>Low level graphic routines can be found between <a class="el" href="hypgraph_8cpp.html" title="mapping hyperpoints to the screen, and related functions">hypgraph.cpp</a> (implementation of various projections &ndash; the major projections use GLSL shaders though), <a class="el" href="shaders_8cpp.html" title="shaders">shaders.cpp</a> (GLSL shaders and other low-level OpenGL routines), <a class="el" href="basegraph_8cpp.html" title="This file implements the basic graphical routines.">basegraph.cpp</a> (various basic stuff), <a class="el" href="drawing_8cpp.html" title="Rendering shapes (dqi_draw), queue of shapes to render (ptds), etc.">drawing.cpp</a> (queue of objects to draw, special handling for spherical geometries), <a class="el" href="control_8cpp.html" title="Routines related to controlling the game.">control.cpp</a> (low-level control).</li>
<li><a class="el" href="graph_8cpp.html" title="Drawing cells, monsters, items, etc.">graph.cpp</a> deals mostly with drawing high-level objects, such as tiles, monsters, and items. The shapes themselves are programmed in <a class="el" href="polygons_8cpp.html" title="shapes used for the vector graphics, mostly hand-drawn (the vector data is here), some procedurally g...">polygons.cpp</a>, floor shapes are adjusted to various geometries in <a class="el" href="floorshapes_8cpp.html" title="Adjusting the floor shapes to various geometries.">floorshapes.cpp</a>.</li>
<li>boring utilities include <a class="el" href="util_8cpp.html" title="basic utility functions: maths, parsing expressions">util.cpp</a> (other basic maths and parsing expressions), <a class="el" href="hprint_8cpp.html" title="Routines related to displaying various things, and writing them to console and files....">hprint.cpp</a> (dealing with files and streams), <a class="el" href="dialogs_8cpp.html" title="Implementation of various generic dialogs and elements of dialog windows.">dialogs.cpp</a> (dialog screens), <a class="el" href="system_8cpp.html" title="changing game modes, starting, closing, loading and saving games">system.cpp</a> (starting new games, changing modes etc.).</li>
</ul>
<h1>HyperRogue gameplay </h1>
<ul>
<li><a class="el" href="classes_8cpp.html" title="items, monsters, walls, lands, descriptions, etc.">classes.cpp</a> and <a class="el" href="content_8cpp.html" title="X-macros for items, monsters, walls, and lands.">content.cpp</a> &ndash; <a class="el" href="content_8cpp.html" title="X-macros for items, monsters, walls, and lands.">content.cpp</a> is actual game content (lands, walls, items, monsters), so if you want to add more, start here.</li>
<li><a class="el" href="landgen_8cpp.html" title="generating various lands">landgen.cpp</a> is basic (local) land generation, while barriers (i.e., Great Walls) are handled in <a class="el" href="barriers_8cpp.html" title="This file implements routines related to barriers (Great Walls and similar).">barriers.cpp</a>, and equidistant surfaces, horocycles etc. are handled in <a class="el" href="bigstuff_8cpp.html" title="Large map structures, such as (horo)cycles and equidistants.">bigstuff.cpp</a>.</li>
<li><a class="el" href="complex_8cpp.html" title="This file implements the gameplay/generation for the more complex lands and mechanics.">complex.cpp</a> and <a class="el" href="complex2_8cpp.html" title="Continuation of complex.cpp.">complex2.cpp</a> defines mechanics which are more unique to specific lands.</li>
<li><a class="el" href="pcmove_8cpp.html" title="PC movements.">pcmove.cpp</a> implements the player movement. Because of the checkmate rule, any changes to the map (made during the player movement, before the monsters' turn) need to be made temporarily. This is done using hr::changes, implemented in <a class="el" href="pcmove_8cpp.html" title="PC movements.">pcmove.cpp</a>.</li>
<li>passable.cpp deals with passability.</li>
<li><a class="el" href="monstergen_8cpp.html" title="monster generation">monstergen.cpp</a> deals with monster generation. This is used mostly for wandering monsters (basic generation during the exploration is handled in <a class="el" href="landgen_8cpp.html" title="generating various lands">landgen.cpp</a>).</li>
<li><a class="el" href="monstermove_8cpp.html" title="monster movement">monstermove.cpp</a> deals with monster movement.</li>
<li><a class="el" href="environment_8cpp.html" title="game environment: routines related to the game that affect all the map. Monsters to move are detected...">environment.cpp</a> deals with the environment: finding all the monster types currently on screen, monstersTurn() function, etc.</li>
<li><a class="el" href="mapeffects_8cpp.html" title="Routines handling the map effects.">mapeffects.cpp</a> deals with various terrain effects (fires, boats, explosions, etc.)</li>
<li>items.cpp deals with items &ndash; mostly, collecting them.</li>
<li><a class="el" href="orbs_8cpp.html" title="Implementation of various Orb effects, and their properties such as default and maximum charges.">orbs.cpp</a> deals with Orb effects, while <a class="el" href="orbgen_8cpp.html" title="Orb generation: which orbs in which lands, functions generating prize/local orbs, etc.">orbgen.cpp</a> deals with Orb generation.</li>
<li>attack.cpp deals with attacks (both by players and monsters) and monster death.</li>
</ul>
<h1>How to use the HyperRogue engine for making visualizations </h1>
<p>The HyperRogue engine includes various "hooks" which can be used to extend the game. For example, a hook can be redefined to add extra commandline parameters, generate new kinds of <a class="el" href="structhr_1_1hrmap.html">hr::hrmap</a>, replace the map-drawing or cell-drawing routines, and so on. This is used thorough the source code to organize things such as commandline parameters, and also can be used to experiment with adding new things. Write a cpp file which includes the file <a class="el" href="hyper_8h.html" title="The main header file of HyperRogue.">hyper.h</a> (to load all the headers), redefines some hooks (for the extra functionality), and compile it with the compiler flag <code>-DCU=1</code> (so just the headers are included) and link it to <code>hyper.o</code>. Rogueviz works this way.</p>
<h1>How to add game content: lands, items, monsters, walls </h1>
<p>The hook system currently does not allow adding new content easily, but you can simply add the new content to the end of the file <a class="el" href="content_8cpp.html" title="X-macros for items, monsters, walls, and lands.">content.cpp</a>. You also need to do the following:</p>
<p>For Lands:</p>
<ul>
<li>Add new entries to hyperrogue-music.txt, these are indexed by integer IDs.</li>
<li>Create the new monsters (as described below), and add entries to isNative in <a class="el" href="landlock_8cpp.html" title="unlocking lands, which lands could be found beyond the wall, validity of various lands depending on t...">landlock.cpp</a>.</li>
<li>Implement the land generation in void giantLandSwitch(cell *c, int d, cell *from) (hint: this function is called for each cell whenever the minimum distance from the player (d) decreases; d=7 are visible and thus they are fully generated)</li>
<li>You probably want to add some wandering monsters at high treasure counts &ndash; see <a class="el" href="monstergen_8cpp.html#a80e28d388c9fda4f41e0966c9f8822c6">wandering()</a> in <a class="el" href="monstergen_8cpp.html" title="monster generation">monstergen.cpp</a></li>
<li>Add new entries to <a class="el" href="graph_8cpp.html" title="Drawing cells, monsters, items, etc.">graph.cpp</a> to draw the new land correctly</li>
<li>To make the land reachable, you should do the following things: (land unlocking is not factored very well)</li>
<li>* add entries to getNewLand in <a class="el" href="landlock_8cpp.html" title="unlocking lands, which lands could be found beyond the wall, validity of various lands depending on t...">landlock.cpp</a>, to make the land actually reachable</li>
<li>* add entries to land_over in <a class="el" href="landlock_8cpp.html" title="unlocking lands, which lands could be found beyond the wall, validity of various lands depending on t...">landlock.cpp</a>, which specifies the order in the Land Overview</li>
<li>* add rules to land_validity if there are any restrictions (note: the default is that there are no restrictions &ndash; the land could appear in Chaos Yendor Challenge)</li>
<li>You might want to add special cases in functions: earthFloor(), earthWall(), summonedAt(), or add a new Yendor Challenge</li>
<li>For the Steam version, achievements and leaderboards should be added</li>
</ul>
<p>For Monsters:</p>
<ul>
<li>If it is an enemy monster, you probably want to add an entry to int* killtable[] in attack.cpp to make the kills count in total kills</li>
<li>Add a case to drawMonsterType in <a class="el" href="graph_8cpp.html" title="Drawing cells, monsters, items, etc.">graph.cpp</a> &ndash; at first you can just change the colors of an existing monster, adding new graphics is described later</li>
<li>To save the kill count correctly, add an applyBoxM line to <a class="el" href="system_8cpp.html" title="changing game modes, starting, closing, loading and saving games">system.cpp</a>, and increase POSSCORE by 1. This has to be added last, to keep compatibility.</li>
</ul>
<p>Adding Items</p>
<ul>
<li>To save the treasure count correctly, add a line applyBoxI(eItem) in <a class="el" href="system_8cpp.html" title="changing game modes, starting, closing, loading and saving games">system.cpp</a>, and increase POSSCORE by 1</li>
<li>To save the Orbs correctly, add lines applyBoxOrb(eItem) and list_invorb(); in <a class="el" href="system_8cpp.html" title="changing game modes, starting, closing, loading and saving games">system.cpp</a>, and increase POSSCORE by 2 (this saves both the current number of charges, and the OSM inventory) This has to be added last, to keep compatibility</li>
<li>For Orbs, you have to add entries to reduceOrbPowers() (maximum charges) and orbcharges() (charges per Orb) in <a class="el" href="orbs_8cpp.html" title="Implementation of various Orb effects, and their properties such as default and maximum charges.">orbs.cpp</a></li>
<li>Treasure pictures are based on the ASCII glyphs by default &ndash; if you want something special, add a case to drawItemType in <a class="el" href="graph_8cpp.html" title="Drawing cells, monsters, items, etc.">graph.cpp</a></li>
</ul>
<p>Adding Wall Types (i.e., any static objects)</p>
<ul>
<li>You need to define how the new wall type reacts to many different effects: boatGoesThrough(), passable(), prespill(), makeflame(), explodeAround(), flashCell(), castLightningBolt(), explodeMine(), summonedAt(), beastcrash() (most of these are in <a class="el" href="mapeffects_8cpp.html" title="Routines handling the map effects.">mapeffects.cpp</a>).</li>
</ul>
<h1>How to add new graphics </h1>
<ul>
<li>Draw a picture in the Vector Graphics Editor, and press Shift+S to get the code</li>
<li>Paste the code into polydata[] in <a class="el" href="polygons_8cpp.html" title="shapes used for the vector graphics, mostly hand-drawn (the vector data is here), some procedurally g...">polygons.cpp</a>, but replace ID by NEWSHAPE, (number identifier)</li>
<li>Add a new shape member (sh*) in <a class="el" href="structhr_1_1geometry__information.html">hr::geometry_information</a></li>
<li>For floor shapes, add a new member of type escher_floorshape in <a class="el" href="structhr_1_1geometry__information.html">hr::geometry_information</a>, and init_escher() call in init_floorshapes() (the parameters are the number identifiers from polydata)</li>
<li>For non-floor shapes, link the new shape global variable to the polydata[] entry in buildpolys() (by calling function bshape)</li>
<li>Add the code using the new shape variable to <a class="el" href="graph_8cpp.html" title="Drawing cells, monsters, items, etc.">graph.cpp</a></li>
</ul>
<h1>How to add configuration </h1>
<ul>
<li>Add a new variable in struct videopar in <a class="el" href="hyper_8h.html" title="The main header file of HyperRogue.">hyper.h</a>, or some other place if you prefer</li>
<li>Provide a default value and config file line in void initConfig() in <a class="el" href="config_8cpp.html" title="Configuration – initial settings, saving/loading ini files, menus, etc.">config.cpp</a></li>
<li>Add a menu entry in the appropriate show* function (hint: old code implements the reaction to selecting the menu option as a case in keyhandler &ndash; the new code just calls the add_action function just after showing the menu option, which is more convenient)</li>
</ul>
<h1>Adding new text (including names and descriptions of lands/items/walls/monsters) </h1>
<ul>
<li>Remember to call XLAT and similar functions instead of writing the text directly, so that it is translated</li>
<li>It is good to list all the added texts (i.e., possible parameters to XLAT) somewhere, so it can be translated</li>
</ul>
<h1>How to add new projections </h1>
<p>This is simple (well, in the easy cases) &ndash; add new entry to classes.h (enum eModel), <a class="el" href="classes_8cpp.html" title="items, monsters, walls, lands, descriptions, etc.">classes.cpp</a> (hr::mdinf), and implement your projection in applymodel() in <a class="el" href="hypgraph_8cpp.html" title="mapping hyperpoints to the screen, and related functions">hypgraph.cpp</a>.</p>
<h1>How to add new geometries (i.e., map structures) </h1>
<p>Well, this is ambitious.</p>
<ul>
<li>Add new entry to classes.h (enum eGeometry), <a class="el" href="classes_8cpp.html" title="items, monsters, walls, lands, descriptions, etc.">classes.cpp</a> (hr::ginf) marking your geometry as "EXPERIMENTAL".</li>
<li>Implement a new subclass of <a class="el" href="structhr_1_1hrmap.html">hr::hrmap</a>. hr::hrmap_binary in <a class="el" href="binary-tiling_8cpp.html" title="Binary tilings in 2D and 3D.">binary-tiling.cpp</a> is a good guide.</li>
<li>If you use the standard bitruncation, or cells correspond 1-1 to heptagons, you do not have to do anything (well, you may need to automatically disable bitruncation in <a class="el" href="#a4201df42c7fd35ed4bfde08a7f9a0f59">hr::set_geometry()</a>). Otherwise modifying <a class="el" href="cell_8cpp.html#a594d51a1a1b73cdee06b3e490c70fbe5">hr::createMov()</a> may be necessary.</li>
<li>Modify <a class="el" href="cell_8cpp.html#a522ed0cb3f181a6813a87ef72438c713">initcells()</a> (or define a hook) to actually create a map in your subclass.</li>
<li>For 3D geometries you need to tell HyperRogue the shape of the faces. See geometry_information::create_wall3d() in <a class="el" href="polygons_8cpp.html" title="shapes used for the vector graphics, mostly hand-drawn (the vector data is here), some procedurally g...">polygons.cpp</a>.</li>
<li>For 2D geometries you need to tell HyperRogue how to draw the cells (see <a class="el" href="floorshapes_8cpp.html" title="Adjusting the floor shapes to various geometries.">floorshapes.cpp</a>) and various geometry details in <a class="el" href="geometry2_8cpp.html" title="Matrices to transform between coordinates of various cells, coordinates of cell corners,...">geometry2.cpp</a>.</li>
<li>Add an entry in <a class="el" href="geom-exp_8cpp.html" title="The &#39;experiments with geometry&#39; menu.">geom-exp.cpp</a> to make your geometry available (otherwise it can be activated with the command line option <code>-geo NameOfMyGeometry</code>).</li>
<li>Once the basic geometry works, you can disable the experimental status of your geometry, and try making things in <a class="el" href="cell_8cpp.html" title="General cells and maps.">cell.cpp</a> (such as cell distances) and <a class="el" href="bigstuff_8cpp.html" title="Large map structures, such as (horo)cycles and equidistants.">bigstuff.cpp</a> (large scale land generation) work. </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
